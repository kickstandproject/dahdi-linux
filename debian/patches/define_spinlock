From: Adam Gandelman <adam.gandelman@canonical.com>
Subject: Move test for DEFINE_SPINLOCK into include/dahdi/kernel.h
Author: Shaun Ruffell <sruffell@digium.com>
Origin: Upstream, http://svnview.digium.com/svn/dahdi?view=revision&revision=9411

The check for DEFINE_SPINLOCK was spread throughout the source tree. If
not defined we can just define it in inlucde/dahdi/kernel.h.  Now
include/dahdi/kernel.h is the only place that references SPIN_LOCK_UNLOCKED 
(which breaks lockdep checking if DEFINE_SPINLOCK is otherwise defined in 
the kernel).


--- a/drivers/dahdi/dahdi-base.c
+++ b/drivers/dahdi/dahdi-base.c
@@ -386,13 +386,8 @@
 
 static LIST_HEAD(zaptimers);
 
-#ifdef DEFINE_SPINLOCK
 static DEFINE_SPINLOCK(zaptimerlock);
 static DEFINE_SPINLOCK(bigzaplock);
-#else
-static spinlock_t zaptimerlock = SPIN_LOCK_UNLOCKED;
-static spinlock_t bigzaplock = SPIN_LOCK_UNLOCKED;
-#endif
 
 struct dahdi_zone {
 	atomic_t refcount;
--- a/drivers/dahdi/dahdi_dynamic.c
+++ b/drivers/dahdi/dahdi_dynamic.c
@@ -113,13 +113,8 @@
 	struct list_head list;
 };
 
-#ifdef DEFINE_SPINLOCK
 static DEFINE_SPINLOCK(dspan_lock);
 static DEFINE_SPINLOCK(driver_lock);
-#else
-static spinlock_t dspan_lock = SPIN_LOCK_UNLOCKED;
-static spinlock_t driver_lock = SPIN_LOCK_UNLOCKED;
-#endif
 
 static LIST_HEAD(dspan_list);
 static LIST_HEAD(driver_list);
--- a/drivers/dahdi/dahdi_dynamic_eth.c
+++ b/drivers/dahdi/dahdi_dynamic_eth.c
@@ -42,11 +42,7 @@
 
 /* We take the raw message, put it in an ethernet frame, and add a
    two byte addressing header at the top for future use */
-#ifdef DEFINE_SPINLOCK
 static DEFINE_SPINLOCK(zlock);
-#else
-static spinlock_t zlock = SPIN_LOCK_UNLOCKED;
-#endif
 
 static struct sk_buff_head skbs;
 
--- a/drivers/dahdi/dahdi_dynamic_ethmf.c
+++ b/drivers/dahdi/dahdi_dynamic_ethmf.c
@@ -129,11 +129,7 @@
 /**
  * Lock for adding and removing items in ethmf_list
  */
-#ifdef DEFINE_SPINLOCK
 static DEFINE_SPINLOCK(ethmf_lock);
-#else
-static spinlock_t ethmf_lock = SPIN_LOCK_UNLOCKED;
-#endif
 
 /**
  * The active list of all running spans
@@ -401,7 +397,7 @@
 	unsigned char addr[ETH_ALEN];
 	int spans_ready = 0, index = 0;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 10)
-	static spinlock_t lock = SPIN_LOCK_UNLOCKED;
+	static DEFINE_SPINLOCK(lock);
 	unsigned long flags;
 #endif
 
--- a/drivers/dahdi/dahdi_dynamic_loc.c
+++ b/drivers/dahdi/dahdi_dynamic_loc.c
@@ -57,11 +57,7 @@
 
 #include <dahdi/kernel.h>
 
-#ifdef DEFINE_SPINLOCK
 static DEFINE_SPINLOCK(zlock);
-#else
-static spinlock_t zlock = SPIN_LOCK_UNLOCKED;
-#endif
 
 static struct ztdlocal {
 	unsigned short key;
--- a/drivers/dahdi/dahdi_transcode.c
+++ b/drivers/dahdi/dahdi_transcode.c
@@ -46,7 +46,7 @@
  * is used as a simplistic way to spread the load amongst the different hardware
  * transcoders in the system. */
 static LIST_HEAD(active_list);
-static spinlock_t translock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(translock);
 
 EXPORT_SYMBOL(dahdi_transcoder_register);
 EXPORT_SYMBOL(dahdi_transcoder_unregister);
--- a/drivers/dahdi/tor2.c
+++ b/drivers/dahdi/tor2.c
@@ -1129,11 +1129,7 @@
 static int syncsrc = 0;
 static int syncnum = 0 /* -1 */;
 static int syncspan = 0;
-#ifdef DEFINE_SPINLOCK
 static DEFINE_SPINLOCK(synclock);
-#else
-static spinlock_t synclock = SPIN_LOCK_UNLOCKED;
-#endif
 
 static int tor2_findsync(struct tor2 *tor)
 {
--- a/drivers/dahdi/wct4xxp/base.c
+++ b/drivers/dahdi/wct4xxp/base.c
@@ -2231,11 +2231,7 @@
 static int syncsrc = 0;
 static int syncnum = 0 /* -1 */;
 static int syncspan = 0;
-#ifdef DEFINE_SPINLOCK
 static DEFINE_SPINLOCK(synclock);
-#else
-static spinlock_t synclock = SPIN_LOCK_UNLOCKED;
-#endif
 
 static void __t4_set_rclk_src(struct t4 *wc, int span)
 {
--- a/drivers/dahdi/wcte12xp/base.c
+++ b/drivers/dahdi/wcte12xp/base.c
@@ -88,7 +88,6 @@
 };
 
 static struct t1 *ifaces[WC_MAX_IFACES];
-spinlock_t ifacelock = SPIN_LOCK_UNLOCKED;
 
 struct t1_desc {
 	const char *name;
--- a/drivers/dahdi/wcte12xp/wcte12xp.h
+++ b/drivers/dahdi/wcte12xp/wcte12xp.h
@@ -77,8 +77,6 @@
 #define TYPE_T1	1
 #define TYPE_E1	2
 
-extern spinlock_t ifacelock;
-
 struct command {
 	struct list_head node;
 	struct completion complete;
--- a/drivers/dahdi/xpp/mmapdrv.c
+++ b/drivers/dahdi/xpp/mmapdrv.c
@@ -68,7 +68,7 @@
 
 static xbus_t *global_xbus;
 static bool tx_ready = 1;
-static spinlock_t tx_ready_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(tx_ready_lock);
 static struct xframe_queue txpool;
 static unsigned int pcm_in_pool_count;
 static bool disconnecting;
--- a/drivers/dahdi/xpp/parport_debug.c
+++ b/drivers/dahdi/xpp/parport_debug.c
@@ -36,7 +36,7 @@
 void flip_parport_bit(unsigned char bitnum)
 {
 	static unsigned char	last_value;
-	spinlock_t	lock = SPIN_LOCK_UNLOCKED;
+	DEFINE_SPINLOCK(lock);
 	unsigned long	flags;
 	unsigned char	mask;
 	unsigned char	value;
--- a/drivers/dahdi/xpp/xbus-core.c
+++ b/drivers/dahdi/xpp/xbus-core.c
@@ -78,7 +78,7 @@
 static void transport_destroy(xbus_t *xbus);
 
 /* Data structures */
-static spinlock_t		xbuses_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(xbuses_lock);
 #ifdef	CONFIG_PROC_FS
 static struct proc_dir_entry	*proc_xbuses = NULL;
 #endif
@@ -405,7 +405,7 @@
 	return (xpacket_t *)(frm->packets + newlen - len);
 }
 
-static spinlock_t serialize_dump_xframe = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(serialize_dump_xframe);
 
 static void do_hexdump(const char msg[], byte *data, uint16_t len)
 {
--- a/drivers/dahdi/xpp/xbus-pcm.c
+++ b/drivers/dahdi/xpp/xbus-pcm.c
@@ -55,8 +55,8 @@
  * I.e: one of our AB or dahdi_ticker
  */
 static struct xpp_ticker	*ref_ticker = NULL;
-static spinlock_t		ref_ticker_lock = SPIN_LOCK_UNLOCKED;
-static spinlock_t		elect_syncer_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(ref_ticker_lock);
+static DEFINE_SPINLOCK(elect_syncer_lock);
 static bool			force_dahdi_sync = 0;	/* from /sys/bus/astribanks/drivers/xppdrv/sync */
 static xbus_t			*global_ticker;
 static struct xpp_ticker	global_ticks_series;
--- a/drivers/dahdi/xpp/xpp_usb.c
+++ b/drivers/dahdi/xpp/xpp_usb.c
@@ -242,7 +242,7 @@
 
 };
 
-static	spinlock_t	xusb_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(xusb_lock);
 static xusb_t *xusb_array[MAX_BUSES] = {};
 static unsigned bus_count = 0;
 
--- a/include/dahdi/kernel.h
+++ b/include/dahdi/kernel.h
@@ -1279,6 +1279,10 @@
 	const struct pci_device_id _x[] __devinitdata
 #endif
 
+#ifndef DEFINE_SPINLOCK
+#define DEFINE_SPINLOCK(x)      spinlock_t x = SPIN_LOCK_UNLOCKED
+#endif
+
 #ifndef DMA_BIT_MASK
 #define DMA_BIT_MASK(n)	(((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
 #endif
